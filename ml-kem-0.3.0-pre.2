Running as unit: run-p897074-i5090765.scope; invocation ID: 8933ae42faf6439e96c9b227a93e5c53
    Updating `tuna` index
 Downloading crates ...
  Downloaded kem v0.4.0-pre.1 (registry `tuna`)
  Downloaded sha3 v0.11.0-rc.0 (registry `tuna`)
   Compiling typenum v1.17.0
    Checking subtle v2.6.1
    Checking rand_core v0.9.3
    Checking zeroize v1.8.1
    Checking keccak v0.2.0-pre.0
    Checking hybrid-array v0.4.5
    Checking crypto-common v0.2.0-rc.4
    Checking block-buffer v0.11.0-rc.5
    Checking digest v0.11.0-rc.3
    Checking kem v0.4.0-pre.1
    Checking sha3 v0.11.0-rc.0
    Checking ml-kem v0.3.0-pre.2 (/getea/tmp/crater-spurious/ml-kem-0.3.0-pre.2)
error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:206:26
    |
206 |     type NttVectorSize = EncodedPolynomialVectorSize<U12, P::K>;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:207:30
    |
207 |     type EncryptionKeySize = Sum<Self::NttVectorSize, U32>;
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:210:5
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:210:5
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed` appears on the `impl`'s associated function `encode_u12` but not on the corresponding trait's associated function
   --> src/param.rs:179:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
179 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self>;
    |        ^^^^^^^^^^ this trait's associated function doesn't have the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:214:5
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:214:5
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed` appears on the `impl`'s associated function `decode_u12` but not on the corresponding trait's associated function
   --> src/param.rs:180:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
180 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K>;
    |        ^^^^^^^^^^ this trait's associated function doesn't have the requirement `&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:218:5
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`
   --> src/param.rs:218:5
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed` appears on the `impl`'s associated function `concat_ct` but not on the corresponding trait's associated function
   --> src/param.rs:182:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
182 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self>;
    |        ^^^^^^^^^ this trait's associated function doesn't have the requirement `hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:222:5
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`
   --> src/param.rs:222:5
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `&hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed` appears on the `impl`'s associated function `split_ct` but not on the corresponding trait's associated function
   --> src/param.rs:183:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
183 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>);
    |        ^^^^^^^^ this trait's associated function doesn't have the requirement `&hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:226:5
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:226:5
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed` appears on the `impl`'s associated function `concat_ek` but not on the corresponding trait's associated function
   --> src/param.rs:185:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
185 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self>;
    |        ^^^^^^^^^ this trait's associated function doesn't have the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`
   --> src/param.rs:226:5
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed` appears on the `impl`'s associated function `concat_ek` but not on the corresponding trait's associated function
   --> src/param.rs:185:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
185 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self>;
    |        ^^^^^^^^^ this trait's associated function doesn't have the requirement `hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output == _`
   --> src/param.rs:230:5
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`
   --> src/param.rs:230:5
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `&hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed` appears on the `impl`'s associated function `split_ek` but not on the corresponding trait's associated function
   --> src/param.rs:186:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
186 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32);
    |        ^^^^^^^^ this trait's associated function doesn't have the requirement `&hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`

error[E0275]: overflow evaluating the requirement `(&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize>, &...) well-formed`
   --> src/param.rs:230:5
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: the requirement `(&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize>, &hybrid_array::Array<u8, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>) well-formed` appears on the `impl`'s associated function `split_ek` but not on the corresponding trait's associated function
   --> src/param.rs:186:8
    |
174 | pub trait PkeParams: ParameterSet {
    |           --------- in this trait
...
186 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32);
    |        ^^^^^^^^ this trait's associated function doesn't have the requirement `(&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize>, &hybrid_array::Array<u8, UInt<UInt<UInt<UInt<UInt<UInt<UTerm, B1>, B0>, B0>, B0>, B0>, B0>>) well-formed`

error[E0275]: overflow evaluating the requirement `P: PkeParams`
   --> src/param.rs:194:23
    |
194 | impl<P> PkeParams for P
    |                       ^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output: Sub<...>`
   --> src/param.rs:204:65
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                                                                 ^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize: Add<...>`
   --> src/param.rs:202:45
    |
202 |     EncodedPolynomialVectorSize<U12, P::K>: Add<U32>,
    |                                             ^^^^^^^^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output: param::ArraySize`
   --> src/param.rs:204:9
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |         ^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output: Sub<...>`
   --> src/param.rs:204:21
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize: Sized`
   --> src/param.rs:204:65
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                                                                 ^^^^^^^^^^^^
    |
note: required by an implicit `Sized` bound in `Sub`
   --> library/core/src/ops/arith.rs:190:0

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize: Sized`
   --> src/param.rs:204:21
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: required by an implicit `Sized` bound in `Sub`
   --> library/core/src/ops/arith.rs:190:0

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output well-formed`
   --> src/param.rs:204:65
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                                                                 ^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize well-formed`
   --> src/param.rs:204:65
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                                                                 ^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize well-formed`
   --> src/param.rs:202:45
    |
202 |     EncodedPolynomialVectorSize<U12, P::K>: Add<U32>,
    |                                             ^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output well-formed`
   --> src/param.rs:204:9
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |         ^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UTerm, ...>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize as Add<...>>::Output well-formed`
   --> src/param.rs:204:21
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize well-formed`
   --> src/param.rs:204:21
    |
204 |         ArraySize + Sub<EncodedPolynomialVectorSize<U12, P::K>, Output = U32>,
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize == _`
   --> src/param.rs:206:5
    |
206 |     type NttVectorSize = EncodedPolynomialVectorSize<U12, P::K>;
    |     ^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<UInt<UInt<UInt<UInt<UTerm, B1>, ...>, ...>, ...> as VectorEncodingSize<...>>::EncodedPolynomialVectorSize well-formed`
   --> src/param.rs:206:5
    |
206 |     type NttVectorSize = EncodedPolynomialVectorSize<U12, P::K>;
    |     ^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<<P as PkeParams>::NttVectorSize as Add<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>>>::Output == _`
   --> src/param.rs:207:5
    |
207 |     type EncryptionKeySize = Sum<Self::NttVectorSize, U32>;
    |     ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<<P as PkeParams>::NttVectorSize as Add<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>>>::Output well-formed`
   --> src/param.rs:207:5
    |
207 |     type EncryptionKeySize = Sum<Self::NttVectorSize, U32>;
    |     ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:210:46
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |                                              ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize>: Sized`
   --> src/param.rs:210:46
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |                                              ^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
    = note: the return type of a function must have a statically known size

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:210:46
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |                                              ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:214:22
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |                      ^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:214:22
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |                      ^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:218:59
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize>: Sized`
   --> src/param.rs:218:59
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
    = note: the return type of a function must have a statically known size

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`
   --> src/param.rs:218:59
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:222:21
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::CiphertextSize> well-formed`
   --> src/param.rs:222:21
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:226:25
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                         ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:226:62
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize>: Sized`
   --> src/param.rs:226:62
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
    = note: the return type of a function must have a statically known size

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize> well-formed`
   --> src/param.rs:226:25
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                         ^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`
   --> src/param.rs:226:62
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:230:21
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:230:53
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <P as PkeParams>::EncryptionKeySize> well-formed`
   --> src/param.rs:230:21
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `(&hybrid_array::Array<u8, <P as PkeParams>::NttVectorSize>, &...) well-formed`
   --> src/param.rs:230:53
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `UInt<UInt<UInt<UInt<UTerm, B1>, B1>, ...>, ...>: EncodingSize`
   --> src/param.rs:211:18
    |
211 |         Encode::<U12>::encode(p)
    |                  ^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
note: required by a bound in `Encode::encode`
   --> src/encode.rs:68:21
    |
 68 | pub trait Encode<D: EncodingSize> {
    |                     ^^^^^^^^^^^^ required by this bound in `Encode::encode`
 69 |     type EncodedSize: ArraySize;
 70 |     fn encode(&self) -> Array<u8, Self::EncodedSize>;
    |        ------ required by a bound in this associated function

error[E0275]: overflow evaluating the requirement `NttVector<<P as ParameterSet>::K>: Encode<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>>`
   --> src/param.rs:211:31
    |
211 |         Encode::<U12>::encode(p)
    |         --------------------- ^
    |         |
    |         required by a bound introduced by this call
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == <NttVector<<P as ParameterSet>::K> as Encode<UInt<..., ...>>>::EncodedSize`
   --> src/param.rs:211:9
    |
211 |         Encode::<U12>::encode(p)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <NttVector<<P as ParameterSet>::K> as Encode<UInt<..., ...>>>::EncodedSize>: Sized`
   --> src/param.rs:211:9
    |
211 |         Encode::<U12>::encode(p)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
    = note: the return type of a function must have a statically known size

error[E0275]: overflow evaluating the requirement `hybrid_array::Array<u8, <NttVector<<P as ParameterSet>::K> as Encode<UInt<..., ...>>>::EncodedSize> well-formed`
   --> src/param.rs:211:9
    |
211 |         Encode::<U12>::encode(p)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:210:69
    |
210 |       fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |  _____________________________________________________________________^
211 | |         Encode::<U12>::encode(p)
212 | |     }
    | |_____^

error[E0275]: overflow evaluating the requirement `<NttVector<<P as ParameterSet>::K> as Encode<UInt<UInt<UInt<..., ...>, ...>, ...>>>::EncodedSize == _`
   --> src/param.rs:211:9
    |
211 |         Encode::<U12>::encode(p)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:210:5
    |
210 |     fn encode_u12(p: &NttVector<Self::K>) -> EncodedNttVector<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `_ == <P as PkeParams>::NttVectorSize`
   --> src/param.rs:214:19
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |                   ^

error[E0275]: overflow evaluating the requirement `UInt<UInt<UInt<UInt<UTerm, B1>, B1>, ...>, ...>: EncodingSize`
   --> src/param.rs:215:18
    |
215 |         Encode::<U12>::decode(v)
    |                  ^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)
note: required by a bound in `Encode::decode`
   --> src/encode.rs:68:21
    |
 68 | pub trait Encode<D: EncodingSize> {
    |                     ^^^^^^^^^^^^ required by this bound in `Encode::decode`
...
 71 |     fn decode(enc: &Array<u8, Self::EncodedSize>) -> Self;
    |        ------ required by a bound in this associated function

error[E0275]: overflow evaluating the requirement `NttVector<<P as ParameterSet>::K>: Encode<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>>`
   --> src/param.rs:215:9
    |
215 |         Encode::<U12>::decode(v)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `_ == <NttVector<<P as ParameterSet>::K> as Encode<UInt<UInt<..., ...>, ...>>>::EncodedSize`
   --> src/param.rs:215:31
    |
215 |         Encode::<U12>::decode(v)
    |                               ^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `&hybrid_array::Array<u8, <NttVector<<P as ParameterSet>::K> as Encode<...>>::EncodedSize> well-formed`
   --> src/param.rs:215:31
    |
215 |         Encode::<U12>::decode(v)
    |                               ^
    |
    = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]` attribute to your crate (`ml_kem`)

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:214:19
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |                   ^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:214:5
    |
214 |     fn decode_u12(v: &EncodedNttVector<Self>) -> NttVector<Self::K> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == <<<P as ParameterSet>::Du as VectorEncodingSize<<... as ParameterSet>::K>>::EncodedPolynomialVectorSize as Add<...>>::Output`
   --> src/param.rs:219:9
    |
219 |         u.concat(v)
    |         ^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:218:83
    |
218 |       fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |  ___________________________________________________________________________________^
219 | |         u.concat(v)
220 | |     }
    | |_____^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:218:5
    |
218 |     fn concat_ct(u: EncodedU<Self>, v: EncodedV<Self>) -> EncodedCiphertext<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `_ == <P as PkeParams>::CiphertextSize`
   --> src/param.rs:222:17
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |                 ^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:222:17
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |                 ^^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>, ...> as Mul<...>>::Output as Sub<...>>::Output == _`
   --> src/param.rs:223:9
    |
223 |         ct.split_ref()
    |         ^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::CiphertextSize == _`
   --> src/param.rs:222:5
    |
222 |     fn split_ct(ct: &EncodedCiphertext<Self>) -> (&EncodedU<Self>, &EncodedV<Self>) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `_ == <P as PkeParams>::NttVectorSize`
   --> src/param.rs:226:18
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                  ^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == <<UInt<UInt<UInt<..., ...>, ...>, ...> as Mul<...>>::Output as Add<...>>::Output`
   --> src/param.rs:227:9
    |
227 |         t_hat.concat(rho)
    |         ^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:226:18
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |                  ^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:226:89
    |
226 |       fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |  _________________________________________________________________________________________^
227 | |         t_hat.concat(rho)
228 | |     }
    | |_____^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:226:5
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:226:5
    |
226 |     fn concat_ek(t_hat: EncodedNttVector<Self>, rho: B32) -> EncodedEncryptionKey<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `_ == <P as PkeParams>::EncryptionKeySize`
   --> src/param.rs:230:17
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                 ^^

error[E0275]: overflow evaluating the requirement `<<P as ParameterSet>::Du as VectorEncodingSize<<P as ParameterSet>::K>>::EncodedPolynomialVectorSize == <P as PkeParams>::NttVectorSize`
   --> src/param.rs:231:9
    |
231 |         ek.split_ref()
    |         ^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:230:17
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |                 ^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:230:85
    |
230 |       fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |  _____________________________________________________________________________________^
231 | |         ek.split_ref()
232 | |     }
    | |_____^

error[E0275]: overflow evaluating the requirement `<<UInt<UInt<UInt<UInt<UInt<..., ...>, ...>, ...>, ...>, ...> as Mul<...>>::Output as Sub<...>>::Output == _`
   --> src/param.rs:231:9
    |
231 |         ek.split_ref()
    |         ^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::EncryptionKeySize == _`
   --> src/param.rs:230:5
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0275]: overflow evaluating the requirement `<P as PkeParams>::NttVectorSize == _`
   --> src/param.rs:230:5
    |
230 |     fn split_ek(ek: &EncodedEncryptionKey<Self>) -> (&EncodedNttVector<Self>, &B32) {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0275`.
error: could not compile `ml-kem` (lib) due to 87 previous errors
